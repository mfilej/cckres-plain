 
Delphi  2.0  je  v  bistvu  paskalski  prevajalnik .  Delphi  2.0  je  naslednja  stopnja  v  razvoju  tistega  prvega  paskalskega  prevajalnika ,  ki  ga  Borland  razvija  že  odkar  je  pred  več  kot  dvanajstimi  leti  Andreas  Hejlsberg  napisal  prvi  prevajalnik  z  imenom  Turbo  Pascal .  Paskalski  programerji  so  lahko  vseskozi  uživali  v  trdnosti ,  uslužnosti  in  seveda  hitrosti  prevajanja ,  ki  ga  Turbo  Pascal  ponuja .  Tudi  Delphi  2.0  pri  tem  ni  nobena  izjema ,  saj  se  v  njem  kaže  več  kot  desetletje  iskušenj  razvijalcev  prevajalnikov  in  nova  doba  32 - bitnih  optimiziranih  prevajalnikov .  Zadovolni  boste ,  ko  boste  ugotovili ,  da  se  Delphi  2.0  prav  v  vsem  odlikuje  kot  vsi  njegovi  predhodniki .

je  cilj  razvijalcev  aplikacij  tipa  odjemalec / strežnik .  Če  razvijate  aplikacijo ,  katera  vzpostavlja  zvezo  s  pomočjo  datotečnega  strežnika  SQL ,  potem  morate  vedeti ,  da  ta  izdaja  vsebuje  vsa  potrebna  orodja  orodja  za  razvijanje  aplikacij  tipa  odjemalec / strežnik .  Client / Server  Suite  vsebuje  vse ,  kar  vsebujeta  ostali  dve  izdaji  Delphija  2.0 ,  poleg  tega  pa  še :

Glavno  okno  v  Delphiju  2.0 .

Orodna  vrstica  Delphija  2.0  je  tudi  spremenljiva !  Kadar  se  nahajate  na  orodni  vrstici ,  vas  desni  gumb  miške  popelje  do  izbire  dodajanja  in  odstranjevanja  gumbov .  Vse  kar  lahko  naredite  v  glavnem  meniju ,  lahko  naredite  hireje  s  pomočjo  gumba  v  orodni  vrstici .  Slika  1.3  kaže  običajno  uporabljeno  orodno  vrstico .

V  oknu  Code  Editor  izvajate  programiranje  v  ožjem  pomenu  besede .  Tukaj  pišete  kodo  katera  določa ,  kako  se  bo  vaš  program  obnašal .  Tukaj  tudi  Delphi  2.0  dodaja  kodo ,  katero  avtomatsko  generira  na  osnovi  gradnikov  v  vaši  aplikaciji .  Na  vrhu  tega  okna  se  nahajajo  jezički ,  vsak  od  njih  se  nanaša  na  svojo  enoto  ali  datoteko .  Vsakič  ko  vaši  aplikaciji  dodate  nov  obrazec ,  se  ustvari  nova  enota  in  se  doda  k  skupini  jezičkov  na  vrhu  okna .  Lahko  pa  k  vaši  aplikaciji  dodate  tudi  dodatne  enote ,  katere  ne  predstavljajo  obrazcev  in  bodo  končale  kot  jezički  na  vrhu  okna  Code  Editor .

uses

end ;

Včasih  imenujemo  ustvarjanje  uporabniškega  vmesnika  in  spošni  izgled  programa  .  V  nevizualnih  okoljih  je  izdelava  prototipa  ( ozadja )  aplikacije  pogosto  vzela  več  časa  kot  pa  pisanje  samega  aplikacije .  Ozadje  je  vse  bistvo  programa ,  kajneda ?  Seveda ,  razpoznaven  in  vizualno  zadovoljiv  uporabniški  vmesnik  je  velik  del  aplikacije ,  ampak  kakšna  bi  bila  korist  od  nje ,  če  bi  npr.  imeli  komunikacijski  program  z  vzorno  izdelanimi  okni  in  pogovornimi  okni ,  pa  ne  bi  bil  zmožen  poslati  podatkov  po  modemu ?  Tudi  pri  aplikacijah  je  tako  kot  pri  ljudeh ;  lepo  je  gledati  lep  obrazek ,  ampak  da  postane  reden  del  našega  življenja ,  pa  nam  mora  nuditi  še  kaj  več .  Zato ,  prosim ,  brez  komentarjev  o  ozadjih .

D :  Double  =  3.14159 ;

const  float  CeloStevilo  =  3.14 ;

Po  želiji  pa  lahku  pri  najavi  določite  tudi  tip  konstante .  To  vam  omogoča  poplen  nadzor  nad  tem ,  kako  prevajalnik  ravna  s  konstantami :

var

inc ( spremenljivka ) ;

{ $ H + }

S2  : =  S2  +  ' popolnoma  drugačnega ! ' ; / /  S2  je  spremenjen ,  torej  je  prepisan  v  svoj  / /  pomnilniški  prostor ,  število  referenc  se  je  / /  zmanjšalo

Dva  niza  lahko  združite  s  pomočjo  operatorja  ali  s  funkcijo  ,  kot  to  kažeta  sledeča  primera :

{  ali  }

RealizeLength ( S ) ; / /  nastavi  dolžino  S  na  nič

Nikoli  ne  shranite  v  nizu  več  znakov ,  kot  ste  rezervirali  prostora .  Če  bi  npr.  najavili  spremenljivko  kot  in  ji  poskušali  prirediti  niz  ' ' ,  bi  bil  niz  odsekan ,  tako  da  bi  ostalo  le  osem  znakov ,  vi  pa  bi  izgubili  kodo . 

S1  : =  ' v  Delphiju  2.0 ' ; / / da  tekst  v  niz  S1

end ;

V1 ,  V2 :  Variant ;

begin

begin

end ;

Uporabniško  definirani  tipi

Polja 

N. i  : =  23 ;

MojZapis  =  record

New ( Zapis ) ; / /  rezervira  pomnilnik  za  Zapis

b :  byte ;

Tipe  lahko  prirejate  le ,  če  se  velikosti  podatkovnih  tipov  ujemata .  Npr.  ne  morete  prirediti  tipa  v  tip  .  Za  pretvorbo  tipa  s  plavajočo  vejico  v  celoštevilčni  tip  uporabite  funkciji  ali  .  Da  pa  pretvorite  celo  število  v  število  s  plavajočo  vejico ,  lahko  uporabite  le  prireditveni  operator :

' Visual  Basic

Če  imate  stavek  ,  ki  dela  več  primerjav ,  potem  se  prepričajte ,  da  ste  vsako  primerjavo  napisali  v  oklepajih ,  saj  drugače  koda  ni  jasna .  Naredite  takole :

end ;

for ( i = 1 ;  i < = 10 ;  i + + )

x  + =  i ;

For  I  =  1  to  10

Vrednost  pa  lahko  vrnete  tudi  tako ,  da  v  funkcijski  kodi  priredite  vrednost  imenu  funkcije .  To  je  standardna  paskalska  zgradba  in  je  ostanek  prejšnjih  različic  Object  Pascala .

begin

Object  Pascal  dovoljuje  tudi  polje  konstant ,  katero  vam  omogoča ,  da  podprogramu  podate  različne  podatkovne  tipe  v  polju .  Skladnja  za  najavo  podprograma ,  kateri  sprejme  polje  konstant ,  je  taka :

vtClass : TypeStr  : =  ' Class ' ; 

interface

Imenujemo  tudi  vsebovane  spremenljivke ;  polja  so  podatkovne  spremenljivke ,  ki  jih  predmeti  vsebujejo .  Polje  v  predmetu  je  prav  takšno ,  kot  je  paskalski  zapis .  V  jeziku  C + +  polja  včasih  imenujemo  tudi  podatkovni  člani .

procedure  JazSemSporočilo ( var  M :  Tmessage ) ;  message  wm _ NekoSporočilo

( javni ) Ta  polja  in  metode  so  dosegljivi  kjerkoli  v  vašem  programu .  Kostruktorji  in  destruktorji  bi  morali  biti  vedno  javni .

Izpis  2.3  prikazuje  uporabo  obravnavanja  izjem  pri  datotečnem  vhodu / izhodu .

Če  boste  definirali  svoj  predmet  izjem ,  potem  ga  izpeljite  iz  znanega  predmeta  izjem ,  kot  je  ali  iz  enega  njegovih  potomcev .  Tako  bodo  lahko  vaše  izjeme  obravnavali  tudi  splošni  krmilniki  izjem .

on  EMathError  do  / /  prestreglo  bo  EMathError  ali  kateregakoli  potomca

tip  prednika  predmeta

V  tem  poglavju  smo  predelali  kar  nekaj  stvari .  Naučili  ste  se  osnovno  skladnjo  in  semantiko  paskalskega  jezika  vključno  s  spremenljivkami ,  operatorji ,  funkcijami ,  procedurami ,  tipi ,  konstrukti  in  stili .  Jasni  pa  vam  morajo  biti  tudi  OOP ,  predmeti ,  polja ,  lastnosti ,  metode ,  ,  obravnavanje  izjem  in  RTTI .

Predmeti  v  16 - bitnih  Oknih  so  se  nanašali  na  entitete ,  do  katerih  smo  lahko  dostopali  preko  ročice .  To  ni  veljalo  za  kernel  predmete ,  saj  ti  v  16 - bitnih  oknih  sploh  še  niso  obstajali .

Win32  okolje  je  predstavilo  novost ,  imenovano  32 - bitni  linearni  pomnilniški  model .  Končno  lahko  paskalski  programerji  najavijo  veliko  polje  ne  da  bi  prevajalnik  javil  napako :

IzročenPomnilnik ,  ki  je  bil  rezerviran  in  določen  fizičnemu  pomnilniku .  Proces  lahko  dostopa  do  izročenega  pomnilnika .  Funkcija  izroči  navidezni  pomnilnik .

Kopice 

Uniči  predmet  na  kopici ,  ki  je  bil  ustvarjen  s  . 

Ponovno  rezervira  blok  pomnilnika  s  kopice ,  kar  vam  omogoča ,  da  spremenite  lastnosti  kopice .

end ;

private

Povedali  smo  že ,  da  so  dogodki  lastnosti .  Kot  podatkovne  lastnosti  se  tudi  dogodki  nanašajo  na  zasebna  podatkovna  polja  gradnikov .  Ta  podatkovna  polja  so  procedurskega  tipa ,  kot  je  .  Poglejte  si  to  kodo :

Koncepta  starševstva  ne  smete  mešati  z  lastništvom .  Gradniki  so  lahko  starši  drugim  gradnikom .  Samo  gradniki  v  oknu ,  kot  so  nasledniki  ,  lahko  služijo  kot  starši  drugim  gradnikom .  Starševski  gradniki  so  odgovorni  za  klicanje  tistih  metod  svojih  otrok ,  s  katerimi  se  ti  izrišejo .  Starševski  gradniki  so  tudi  odgovorni  za  pravilni  izgled  svojih  otrok .  Starševski  gradnik  je  določen  skozi  gradnikovo  lastnost  .

Starševski  gradnik  še  ni  nujno  lastnik  gradnika .  Popolnoma  legalno  za  gradnike  je ,  da  imajo  različne  starše  in  lastnike .

Poglejte  si  proceduro  najavljeno  v  zasebnem  delu  glavnega  obrazca .  Ta  procedura  poskrbi  za  izpis  imena  razreda  in  prednikov  v  na  glavnem  obrazcu .

Prikaz  projekta  informacij  o  razredu

Razred  izhaja  direktno  iz  .  Skoraj  vsi  gradniki ,  ki  jih  uporabljamo  v  Delphiju ,  izhajajo  iz  .  Posebni  nameni  so ,  da  njegove  lastnosti  lahko  oblikujemo  v  času  razvijanja  aplikacije  v  oknu  Object  Inspector  in  da  je  lahko  lastnik  drugih  gradnikov .

MojSeznamNizov . Add ( ' Pink  Floyd ' ) ; 

Tabela  4.4  prikazuje  nekatere  pogosteje  uporabljene  metode  razreda  .  Uporabo  teh  funkcij  boste  spoznali  v  kasnejših  poglavjih .

Zgradba  aplikacij  in  koncepti  oblikovanja

nastane  v  času  oblikovanja  in  ima  končnico  DPR .  V  tej  datoteki  se  nahaja  izvorna  koda  glavnega  programa .  V  projektni  datoteki  je  shranjen  glavni  obrazec  in  vsi  avtomatsko  ustvarjeni  obrazci .  Teh  datotek  vam  navadno  ne  bo  potrebno  urejati ,  razen  pri  podprogramih  za  inicializacijo  programa ,  za  prikaz  začetne  slike  in  pri  raznih  drugih  podprogramih ,  ki  se  morajo  izvršiti  takoj ,  ko  program  zaženemo .  Tipično  projektno  datoteko  lahko  vidite  v  izpisu  5.1 .

Obstaja  veliko  načinov  za  izboljšanje  postopka  razvijanja ,  predvsem  s  pomočjo  tehnik ,  katere  omogočajo  boljšo  organizacijo  in  preglednost ,  pa  tudi  deljenje  kode .  V  sledečih  odstavkih  vam  bomo  dali  nakaj  takšnih  nasvetov .

Enote  za  globalne  najave 

Ta  koda  prikazuje ,  kako  lahko  dinamično  ustvarite  izvod  in  ga  priredite  spremenljivki  .  Pomembno  je  vedeti ,  da  morate ,  kadar  obrazec  ustvarite  dinamično ,  tega  odstraniti  iz  seznama  obrazcev  za  avtomatsko  kreiranje  ( auto - create )  v  pogovornem  oknu  Project  Options .  Do  tega  pogovornega  okna  pridete  z  izbiro  menija  Project  |  Options .  Če  pa  je  izvod  že  narejen ,  potem  lahko  obrazec  s  pomočjo  metode  pokažete  kot  modalnega .  Koda  lahko  izgleda  takole :

begin

end ;

Ta  vrstica  preveri ,  če  obstaja  izvod  ,  na  katerega  kaže  spremenljivka  .  V  resnici  tukaj  le  preverimo ,  če  je  enak  .  Čeprav  sicer  ne  bo  ,  ko  boste  privič  vstopili  v  ta  podprogram ,  pa  bo  ob  drugem  vstopu  v  podprogram  enak  ,  potem  ko  boste  prvi  izvod  že  uničili .  Razlog  tiči  v  tem ,  da  VCL  ne  nastavi  spremenljivke  na  ,  ko  je  obrazec  uničen ,  zato  morate  to  narediti  sami .

Form1 . Show ;

SysUtils ,  WinTypes ,  WinProcs ,  Messages ,  Classes ,  Graphics ,  Controls ,  Forms ,  Dialogs ;

Izpis  5.5  PWDLG . PAS ,  Obrazec  in  njegov  gradniški  ovoj  .

se  imenuje  gradnik ,  ker  ga  ovijemo  okrog  obrazca ,  tako  da  ga  lahko  postavimo  na  paleto  gradnikov  Delphija  2.0 .

V  eni  izmed  prejšnjih  vrstic  kode  ste  lahko  videli ,  kako  dostopamo  do  lastnosti  in  s  tem  spremenimo  njeno  lastnost  ,  tako  da  vsebuje  aplikacije .  kaže  na  ,  tako  da  lahko  skozi  dostopate  do  katerekoli  lastnosti  .  Lahko  tudi  dostopate  do  lastnosti ,  katere  ste  dodali  vašim  dedovanim  obrazcem ,  vendar  morate  pri  tem  ustrezno  prirediti  tip  :

Tabela  5.1 .  Lastnosti  .

Kaže  obrazec  v  žarišču .  Ta  lastnost  se  spremeni ,  ko  dobi  žarišče  drug  obrazec  ali  ko  aplikacija  v  Delphiju  dobi  žarišče  od  druge  aplikacije .

end ;

Vendar  pa ,  če  hočete ,  da  ta  koda  deluje  pravilno ,  mora  DPR  izgledati  takole  ( z  dodatnim  navodilom  prevajalniku  za  povezovanje  datoteke  virov ) :

Kot  ste  spoznali  v  3.  poglavju ,  " Win32  API " ,  ima  Win32  API  zelo  močno  orodje  za  delo  z  napakami :  izjeme .  Po  prevzetem  izvod  avtomatsko  obravnava  vsako  izjemo ,  ki  nastopi  tako ,  da  izpiše  uporabniku  okno  s  sporočilom  o  napaki ,  kot  ga  lahko  vidite  na  sliki  5.9 .

Vendar  pa  se  spomnite ,  da  lastnosti  predmeta  ne  morete  urejati  v  oknu  Object  Inspector .  Tem  lastnostim  morate  prirediti  proceduro  med  izvajanjem .

V  začetku  tega  poglavja  smo  povedali ,  da  so  obrazci  srce  vseh  aplikacij  v  Delphiju .  Vendar  pa  vam  nič  ne  preprečuje ,  da  ne  bi  naredili  aplikacije ,  ki  ne  bi  imela  niti  enega  samega  obrazca .  DPR  datoteka  ni  nič  drugega  kot  programska  datoteka ,  ki  uporablja  enote ,  v  katerih  so  definirani  obrazci  in  drugi  predmeti .  Taka  programska  datoteka  pa  seveda  lahko  deluje  brez  obrazcev .  Če  hočete  to  narediti ,  potem  preprosto  začnite  nov  projekt  in  odstranite  njegov  glavni  obrazec  z  izbiro  File  |  Remove  From  Project .  Potem  bo  vaša  DPR  datoteka  izgledala  takole :

Izpis  5.10 .  Zapuščanje  oken  s  pomočjo  in  .

Aplikacije  za  delo  z  datotekami .  To  so  tiste  aplikacije ,  ki  imajo  v  meniju  Datoteka  ( File )  izbire  Odpri  ( Open ) ,  Shrani  ( Save )  in  Zapri  ( Close ) .

Prijavi  ikone  velikosti  16  x  16  in  32  x  32  točk  za  tipe  datotek ,  uporabljene  v  aplikaciji ,  pa  tudi  za  ikono  aplikacije .

Zahteve  za  uslužnostne  aplikacije 

Podpira  lupino  uporabniškega  vmesnika  Windows  95 ,  zato  mora  ustrezati  sledečim  zahtevam :

Okno  je  bilo  aktivivirano  ali  deaktivirano .

Kako  deluje  Okenski  sistem  sporočil

MessageBeep ( 0 ) ;

v  bo  spuščen .

sprejema  vhodno  žarišče .

Uporabnik  je  kliknil  na  drsnik .

VCL  vsebuje  razširjeno  zbirko  svojih  notranjih  objavljenih  sporočil .  Čeprav  v  svojih  Delphijevih  aplikacijah  teh  sporočil  ne  uporabljate  pogosto ,  pa  bodo  uporabna  za  razvijalce  gradnikov  v  Delphiju .  Ta  sporočila  govorijo  o  stanjih ,  kot  so  žarišče ,  barva  in  vidnost .  Popolno  zbirko  teh  sporočil  lahko  najdete  v  pomoči  razvijalcev  gradnikov  ( CWG . HLP  -  Component  Writer's  help )  pod  temo  .

var

SLIKA  6.3

Tip  je  enak  tipu  v  Delphiju  1.0 .  Kot  enozložni  znak  lahko  vsebuje  256  različnih  znakov .  uporabite  samo ,  kadar  ste  prepričani ,  da  bo  znakovna  spremenljivka  vedno  enozložna .

procedure  SetLength ( var  S :  String ;  NovaDolzina :  Integer ) ;

end ;

DisposeStr ( S2 ) ;

begin

end ;

Nizi  s  končnim  ničelnim  znakom  kot  vmesni  pomnilniki 

Pogosta  je  uporaba  spremenljivk  za  vmesni  pomnilnik ,  ki  je  podan  API  funkcijam ,  katere  napolnijo  niz  z  informacijo .  Klasičen  primer  je  API  funkcija  ,  katera  je  takole  definirana  v  Win32  API :

Če  želite  shraniti  Okenski  imenik  v  spremenljivko  niza ,  je  v  Delphiju  1.0  najlažji  način  za  to ,  da  podate  naslov  prvega  elementa  niza ,  kot  kaže  primer :

var

var

P :  PChar ;

end ;

initialization

MyGlobalObject . Free ;

Delphi  2.0  predstavlja  navodila  za  uporabo  dveh  novih  konvencij  klicanja :  in  .  Prevzeta  konvencija  klicanja  pri  Delphiju  2.0  je  ,  saj  omogoča  hitrejše  izvajanje .  Ta  metoda  podajanja  parametrov  narekuje ,  da  so  prvi  trije  parametri  podani  vsak  zase  v  registrih  ,  in  .  Ostali  parametri  uporabijo  sistem  klicanja  .  Konvencija  klicanja  pa  je  nekaj  vmes  med  in  ,  saj  pomeni  podajanje  parametrov  kot  pri  ,  čiščenje  sklada  pa  kot  pri  .

32 - bitni  viri 

Če  želite  shraniti  sliko ,  uporabite  metodo  SaveToFile ( ) ,  ki  samodejno  določi  tip  datoteke  za  shranitev :

Če  želite  eno  bitno  sliko  prekopirati  na  drugo ,  uporabite  metodo  TBitmap . Assign ( )  kot  sledi :

Tabela  * * * 

Slog  Nariše

psDot  Črto ,  izdelano  iz  pik

SLIKA  9.1 .  Različni  slogi  peresa .

Krmilnik  dogodka  PenMode1Click ( )  kaže ,  kako  se  rišejo  črte  z  uporabo  različnih  načinov  peresa .  Tukaj  za  izvajanje  dejanj ,  ki  smo  jih  razložili  predhodno ,  uporabljamo  način  pmNotMerge ,  kar  povzroči  rezultat ,  ki  je  prikazan  na  sliki  9.2 .

Čopič  zapolni  področja  in  oblike ,  narisane  na  platnu .  To  se  od  TPen  razlikuje  v  tem ,  da  TPen  omogoča  risanje  črt  na  platnu ,  čopič  pa  zapolnitev  področja  na  platnu  z  uporabo  različnih  barv ,  slogov  in  vzorcev . 

Metoda  Patterns1Click ( )  kaže  risanje  z  različnimi  vzorci  TBrush .  Najprej  izrišemo  naslove ,  nato  pa  na  platno  obrazca  z  uporabo  razpoložljivih  vzorcev  čopiča  izrišemo  pravokotnike .  Na  sliki  9.4  je  prikazan  rezultat  te  metode .

Image1 . Canvas . Rectangle ( ,  ,  Image1 . Width ,  Image1 . Height ) ;

Font . Color  lahko  dodelite  katerokoli  izmed  že  definiranih  barv  Delphija  2.0 .  Naslednja  koda  pisavi  platna  dodeli  rdečo  barvo :

fsStrikeOut  Vodoravna  črta  prek  pisave ,  ki  daje  prečrtan  videz

Form1 . Font  : =  Form2 . Font

TCanvas . ClipRect  predstavlja  področje  platna ,  na  katerem  se  lahko  riše .

Glavni  obrazec  ima  10  metod ,  ki  so  krmilniki  dogodkov  za  vsako  menijsko  postavko .  Dve  javni  metodi  služita  kot  pomožni  funkciji  za  krmilnike  dogodkov .  Prvih  osem  menijskih  postavk  povzroči ,  da  se  na  platnu  obrazca  narišejo  oblike .  Zadnji  dve  postavki ,  Fill  ( Zapolni )  in  Use  Bitmap  Pattern  ( Uporabi  vzorec  bitne  slike )  podajata ,  ali  naj  bo  oblika  zapolnjena  z  vzorcem  čopiča  oziroma  bitne  slike .

case  Integer  of

TextSize1Click ( )  kaže ,  kako  se  določi  velikost  besedilnega  niza  z  uporabo  metod  TCanvas . TextWidth ( )  in  TCanvas . TextHeight ( ) .  Rezultat  te  metode  je  prikazan  na  sliki  9.11 .

try

Win32  omogoča ,  da  definirate  preslikovalni  način  za  DC  ali  Canvas . Handle .  Win32  definira  osem  preslikovalnih  načinov ,  ki  jih  lahko  uporabite .  Ti  preslikovalni  načini ,  skupaj  z  njihovimi  lastnostmi ,  so  prikazani  v  tabeli  9.4 .  Vzorčni  projekt  v  naslednjem  razdelku  bolj  podrobno  prikazuje  preslikovalne  načine .

Metoda  MMANISOTROPICClick ( )  izvede  enako  operacijo ,  z  razliko ,  da  uporabi  način  MM _ ANISOTROPIC .  Obe  metodi  prikazujemo  zato ,  da  pokažemo  osnovno  razliko  med  preslikovalnima  načinoma  MM _ ISOTROPIC  in  MM _ ANISOTROPIC . 

Tehnike  TPanel 

Kot  smo  že  dejali ,  je  velik  del  delovanja  risalnega  programa  razložen  v  opombah  v  kodi .  Priporočamo ,  da  preberete  kodo  in  opombe ,  da  boste  lahko  razumeli ,  kaj  se  dogaja  v  programu .

Ozadje  Vrednost  Barva

SLIKA  9.21 .  # FOrImage .

Višina  Vsota  ascendenta ,  descendenta  in  notranje  zapolnitve .

lfUnderline :  Byte ;

fillChar ( ALogFont ,  sizeof ( TLogFont ) ,  ) ;

Metoda  SetDefaults ( )  inicializira  strukturo  TLOGFONT  s  privzetimi  vrednostmi .  Ta  metoda  je  poklicana  pri  izdelavi  glavnega  obrazca  in  vsakič ,  ko  uporabnik  pritisne  gumb  Set  Defaults  ( Nastavi  privzetke ) .  Preizkušajte  ta  projekt ,  če  želite  videti  različne  učinke ,  ki  jih  ima  lahko  pisava ,  kot  je  prikazano  na  sliki  9.28 .

tmAveCharWidth :  Integer ;

tmStruckOut :  Byte ;

TWorthless  =  class ( TCustomControl )

Dodajanje  predmetnih  lastnosti  h  gradnikom 

Da  bomo  lahko  definirali  predmetno  lastnost  za  gradnik  ,  moramo  najprej  definirati  predmet ,  ki  bo  služil  kot  tip  te  lastnosti .  Ta  predmet  je  prikazan  v  izpisu  11.4 .

Konstruktor  smo  definirali  takole :

property  SomeObject :  TSomeObject  read  FSomeObject  write  FSomeObject ;

end ;

Ustvarjanje  metod 

Nasvet  za  pomoč : Preden  Delphi  na  novo  zgradi  knjižnico  gradnikov ,  naredi  razervno  kopijo  datoteke  in  jo  imenuje  CMPLIB32 . ~ DC .  Če  se  vaša  CMPLIB32  pokvari ,  lahko  samo  preimenujete  razervno  datoteko  v  CMPLIB32 . DCL.  Ali  pa ,  v  skrajnem  primeru  skopirajte  CMPLIB32 . DCL  iz  imenika  \ RUNIMAGE \ DELPHI \ BIN  na  zgoščenki  Delphija  2.0 .

Najprej  bomo  pogledali  sposobnost  ,  ki  nam  omogoči  informacijo  o  vrstici  in  stolpcu .  Vidite  lahko ,  da  smo  h  gradniku  dodali  dve  zasebni  polji ,  in  .  Ti  dve  polji  bosta  vsebovali  položaj  vrstice  in  stolpca  kurzorja  v  .  Vidite  lahko  tudi  javni  lastnosti  in  .  Ti  metodi  sta  javni ,  saj  med  oblikovnajam  gradnika  nimamo  od  njiju  nobene  koristi .  Lastnosti  in  imata  obe  dostopni  metodi  za  branje  in  pisanje .  Za  lastnost  sta  ti  metodi  in  ,  za  pa  in  .  Za  praktično  uporabo  bi  verjetno  lahko  odstranili  shranitvena  polja  in  ,  saj  so  vredosti  in  omogočene  skozi  dostopne  metode .  Vendar  pa  smo  jih  pustili  tam ,  saj  to  ponuja  možnost  razširitve  gradnika .

Gradnik  vsebuje  tudi  dva  nova  gradnika :  in  .  Dogodek  se  zgodi ,  ko  uporabnik  klikne  na  vodoravni  drsnik  kontrole ,  pa  ko  uporabnik  klikne  na  navpični  drsnik .  Da  lahko  sprožimo  take  dogodke ,  moramo  prestreči  sporočili  Win32  in  ,  ki  sta  poslani  kontroli  kadarkoli  uporabnik  klikne  na  katerikoli  drsnik .  Tako  smo  naredili  dva  dogodkovna  krmilnika :  in  .  Ta  dva  dogodkovna  krmilnika  pokličeta  metodi  za  razpošiljanje  sporočil  in  .  Ti  metodi  preverita ,  če  je  uporabinik  gradnika  priskrbel  dogodkovna  krmilnika  za  dogodka  in  in  potem  pokličeta  ta  dva  dogodkovna  krmilnika .  Če  se  sprašujete ,  zakaj  tega  nismo  preverili  že  kar  v  dogodkovnem  krmilniku  metode ,  smo  to  naredili  zato ,  ker  boste  pogosto  želeli  poklicati  dogodkovni  krmilnik  kot  rezultat  različnih  akcij ,  kot  npr.  ko  uporabnik  spremeni  položaj  kurzorja .

Kot  dodatno  ugodnost  pa  smo  naredili  gradnik  ,  ki  povzema  funkcijo  in  omogoča  vizualno  predstavitev  aplikacije ,  katera  se  bo  izvršila .  Vse ,  kar  mora  uporabnik  narediti ,  je ,  da  pritisne  na  gumb  in  aplikacija  se  izvrši .

Izpis  11.13 .  RUNBTN . PAS ,  izvorna  koda  za  gradnik  . 

je  priročna  uslužnostna  funkcija ,  ki  jo  boste  verjetno  želeli  imeti  v  ločeni  enoti ,  tako  da  jo  boste  lahko  delili  z  drugimi  aplikacijami .  Dejansko  smo  jo  vključili  v  našo  lastno  datoteko  UTILS . PAS  v  \ CODE \ UTILS \ XXXX . PAS .

Ker  je  Object  Pascal  zgrajen  na  osnovi  predmetnega  modela  enostranskega  dedovanja ,  mora  biti  svoj  gradnik ,  ki  mora  vsebovati  tako  kot  tudi  .  Ker  mora  ta  gradnik  vsebovati  uokvirjene  kontrole ,  mora  biti  tudi  sam  uokvirjena  kontrola .  Zato  smo  se  odločili ,  da  deduje  iz  in  da  naredi  in  v  konstruktorju  gradnika  s  sledečo  kodo :

begin

FHeader  : =  THeaderControl . Create ( Self ) / /  naredi  HeaderControl

/ /  ostale  stvari

Pojavi  se  vsako  sekundo .

Začnite  z  uvodnimi  pripravami  -  ne  navalite  takoj  na  gradnik .  Vprašajte  se ,  kaj  najprej  potrebujete ,  da  bo  ta  gradnik  lahko  deloval .

Poseben  psevdo - vizualen  gradnik ,  ki  bo  predstavljen  v  tem  podpoglavju ,  je  izboljšan  gradnik  za  namige .  Razlog ,  da  smo  ta  gradnik  poimenovali  psevdo - vizualen  gradnik  je  preprosto  v  tem ,  da  se  v  času  izdelave  programa  ne  vidi .  Na  obrazce  ga  ne  postavljate  ( rišete ) ,  a  kljub  temu  se  med  izvajanjem  programa  vidi ,  če  se  z  miško  postavite  na  določeno  mesto . 

4.  Prireditev  novega  razreda  za  namige .

procedure  TMarquee . PaintLine ( R :  TRect ;  LineNum :  integer ) ;

{  this  method  is  called  to  paint  each  line  of  text  onto  MemBitmap  }

URect :  TRect ;

begin

ScrollPixels  > =  CurrLine  then

Izpis  12.2  Izvorna  koda  enote  Marquee . PAS

Add ( ' Bobby ' ) ;

Add ( ' Cindy ' ) ;

end ;

Opis

Privzet  urejevalnik  za  imena  naborov  znakov .  Ta  urejevalnik  naredi  seznam  vseh  naborov  znakov ,  ki  so  dosegljivi  v  sistemu .

procedure  RegisterPropertyEditor ( PropertyType :  PTypeInfo ;  ComponentClass :  TClass ;  const  PropertyName :  string ;  EditorClass :  TPropertyEditorClass ) ;

Izpis  12.6  prikazuje  definicijo  za  urejevalnik  lastnosti  podatkovnega  tipa  .

{  Descend  from  the  TStringProperty  class  so  that  this  editor

Result  : =  [ paDialog ] ;  / /  Display  a  dialog  in  the  Edit  method

end ;

Verjetno  še  ne  veste ,  toda  za  vsak  gradnik  se  ob  urejanju  obrazca  odpre  drug  urejevalnik .  Tip  urejevalnika ,  ki  se  ustvari ,  je  odvisen  od  izbranega  gradnika ,  čeprav  pa  vsi  urejevalniki  gradnikov  izhajajo  iz  razreda  .  Ta  razred  je  deklariran  kot :

end ;

end ;

V  proceduri  pa  sta  parametra  in  podatkovnega  tipa  ,  ki  je  deklariran  kot :

FInteger  : =  Reader . ReadInteger ;

{  any  memory  previously  allocated  for  FData .  }

if  not  Empty  then

Metoda  najprej  preveri ,  ali  mogoče  pomnilnik  ni  bil  že  prej  zasežen  ( to  naredi  s  testom  lastnosti  .  Če  je  vrednost  večja  od  0 ,  se  pomnilnik ,  na  katerega  kaže  ,  sprosti .  Nadalje  se  za  rezervira  nov  kos  pomnilnika ,  njegova  velikost  pa  se  zapiše  v  .  Vrednost  toka  se  nato  prebere  v  ,  ki  ima  tako  dovolj  prostora ,  da  sprejme  vse  želene  podatke .

end ;

public

TNotifyIcondata  =  record

if  not  ( AOwner  is  TForm )  then

raise  ENotifyIconError . Create ( ' Owner  must  be  a  TForm ' ) ;

FIcon . Assign ( Value ) ;  / /  set  new  icon

{  Change  icon  on  notification  tray  }

case  lParam  of

{  Popup  local  menu  at  the  cursor  position .  }

const

Izpis  12.13  Enota  Main . PAS

Operacijski  sistem  Win32  nam  omogoča  uporabo  več  poti  izvajanja  ( več  niti )  v  programu .  Če  bi  morali  izpostaviti  eno  samo ,  najpomembnejšo  prednost ,  ki  jo  imajo  32 - bitna  Okna  pred  16 - bitnimi  Okni ,  bi  bile  to  nedvomno  niti ,  saj  nam  omogočajo  hkratno  izvajanje  različnih  operacij  v  programu .  Niti  so  tudi  eden  izmed  najočitnejših  razlogov  za  nakup  Delphi-ja  2  in  v  tem  poglavju  se  bomo  naučili  vseh  podrobnosti ,  ki  nam  iz  niti  omogočajo  iztisniti  največ .

Najpogostejša  uporaba  niti 

Slika  13.1 :  Izbor  Thread  Object  v  pogovornem  oknu  New  Items .

Procedure  TForm1 . Button1Click ( Sender :  TObject ) ;

i :  integer ;

unit  ThrdU ;

{ $ R  * . DFM }

NewThread :  TTestThread ;

TThreadPriority  =  ( tpIdle ,  tpLewest ,  tpLower ,  tpNormal ,  tpHigher ,  tpHighest ,  tpTimeCritical ) ;

function  GetThreadTimes ( hThread :  THandle ;  var  lpCreationTime ,  lpExitTime ,  lpKernelTime ,  lpUserTime :  TFileTime ) :  BOOL ;  stdcall ;

Čas ,  ko  se  je  nit  zaključila .  Če  nit  še  obstaja ,  je  vrednost  parametra  nedefinirana .

DecodeDate ( DateTime ,  wYear ,  wMonth ,  wDay ) ;

FNewStr :  String ;

procedure  TMainForm . Button1Click ( Sender :  TObject ) ;

SetShowStr ( ' ' ) ;

procedure  ThreadsDone ( Sender :  TObject ) ;

implementation

Result  : =  NextNumber ;  / /  return  global  var

Rešitev  tega  problema  je  v  sinhronizaciji  niti ,  da  le  ti  ne  dostopata  do  globalega  polja  hkrati .  Izberemo  lahko  več  možnosti .  Za  rešitev  obstaja  precej  možnosti  in  vse  so  pravilne .

end ;

Sleep ( 5 ) ;  / /  let  thread  intertwine

end ;

procedure  Execute ;  override ;

MaxSize  =  128 ;

end ;

Label3 :  TLabel ;

{  Private  declarations  }

end ;

end ;

ukažete  operacijskemu  sistemu ,  naj  rezervira  zlogov  pomnilnika ,  ki  jih  lahko  premika  po  pomnilniku .  Kot  rezultat  naj  vrne  ročico  na  ta  blok  v  spremenljivko  .  Iz  ročice  dobimo  kazalec  s  klicem  funkcije

procedure  DdeServerItem1PokeData ( Sender :  TObject ) ;

DDEServerItem1 . Text  : =  Edit1 . Text ;

procedure  TMain . Button1Click ( Sender :  TObject ) ;

procedure  TMain . Button2Click ( Sender :  TObject ) ;

Izdelava  avtomatizacijskih  OLE  nadzornikov 

Label2 :  TLabel ;

ConnectBtn :  TButton ;

end ;

ContForm :  TContForm ;

{ $ R  * . DFM }

uses  OLEAuto ;

EnableBtns ( True ) ;

StdCtrls ;

CLSCTX _ SERVER  =  CLSCTX _ INPROC _ SERVER  or  CLSCTX _ LOCAL _ SERVER ;

Slika  15.16  Pregled  relacij  v  sistemskem  registru

Sent  To  ‘ SentTo ’

end ;

begin

end ;

implementation

try

ToolServices  : =  AToolServices ;

end

OpenDialog :  TOpenDialog ;

{ $ R  * . DFM }

{ $ ifdef  BUILD _ EXE }

var  Terminate :  TExpertTerminateProc ) :  Boolean ;  stdcall ;

Result  : =  esStandard ;

MainForm . Free ;

end ;

except

end .

ToolServices . OpenFile ( FileStr )

To  poglavje  vam  je  dalo  osnoven  vpogled  v  vmesnike ,  ki  sestavljajo  Delphi-jev  Open  Tools  API .  Vedeti  in  razumeti  morate  predvsem  izgradnjo  ekspertov  in  njihovo  vklapljanje  v  IDE .  V  naslednjem  poglavju  boste  spoznali  vse ,  kar  ste  kadarkoli  želeli  vedeti  o  dinamičnih  knjižnicah ,  njihovi  izgradnji  v  Delphi-ju ,  uporabi  in  različnih  trikih  v  zvezi  z  njimi .

Opazili  boste ,  da  enota  izgleda  povsem  tipično ,  toda  funkcije  Max ( )  ne  definira ,  temveč  jo  samo  deklarira .  Rezervirana  beseda  external  pove ,  da  se  funkcija  nahaja  v  DLL-u ,  katerega  ime  sledi .  Za  uporabo  te  enote  mora  aplikacija  samo  dodati  njeno  ime  v  usus  stavek .  Ko  aplikacijo  poženete ,  se  DLL  avtomatično  naloži  in  vsak  dostop  do  funkcije  Max ( )  se  preslika  v  DLL .

Skrivanje  implementacije 

Odgovarjajoča  povezava  z  DLL-om  je  zapisana  v  sekciji  implementation  in  izgleda  takole :

{  This  record  will  hold  the  denominations  after  the  conversions  have

Pennies  : =  TotPennies ;

{  Export  the  function  by  name  }

To  poglavje  vam  razkriva ,  kako  lahko  DLL-i  uporabljajo  vaše  obrazce .  Eden  izmed  razlogov  za  uvrstitev  pogostih  obrazcev  v  DLL  je  zmožnost  razširitve  uporabe  vaših  obrazcev  v  vseh  razvojnih  okoljih  Oken ,  recimo  C + + ,  Visual  Basic  ali  Object  PAL .

{  If  the  function  is  imported  successfully ,  then  Label1  to  reflect

Funkcija  FreeLibrary ( )  je  deklarirana  kot :

Dogodek  Namen

Windows ,  Messages ,  SysUtils ,  Classes ,  Graphics ,  Controls ,

procedure  Button3Click ( Sender :  TObject ) ;

end ;

procedure  TForm1 . Button2Click ( Sender :  TObject ) ;

LibHandle  : =  0 ;

DLLProc  : =  @ DLLEntryPoint ;

Pritisk  na  drugi  gumb  izvede  metodo  Button2Click ( ) ,  ki  kliče  funkcijo  FreeLibrary ( )  in  sprosti  dinamično  knjižnico  iz  pomnilnika .  Ko  se  to  zgodi ,  se  izvede  procedura ,  na  katero  kaže  spremenljivka  DLLProc  ( v  konkretnem  primeru  je  to  procedura  DLLEntryPoint ( ) )  in  posreduje  se  ji  parameter  DLL _ PROCESS _ DETACH .

call  back  function  EnumWindowsProc  which  will  be  called  for  each

TWindowInfo ( ListBox1 . Items . Objects [ i . . . Free

begin

string  }

end ;

{  Return  true  by  default  which  indicates  not  to  stop  enumerating

Result  : =  True ;

begin

end ;

procedure  Button1Click ( Sender :  TObject ) ;

S :  String ;

ShowMessage ( ' The  word  ' + Edit1 . Text + '  occurs  '

ShareMem ,

Classes ;

procedure  OpenSharedData ;

{  Initialize  this  data  }

Za  ilustracijo  uporabe  opisanega  DLL-a  boste  razvili  dve  aplikaciji ,  ki  ga  uporabljata .  Prva  aplikacija ,  SHARETEST . EXE  ,  vam  dovoli  spreminjanje  podatkov  DLL-a .  Druga  aplikacija  ( APP2 . EXE )  ravno  tako  uporablja  iste  podatke  in  s  pomočjo  ure  nenehno  obnavlja  oznaki ,  ki  vsebujeta  vrednost  teh  podatkov .  Ko  boste  pognali  obe  aplikaciji ,  boste  videli  deljivost  podatkov ,  saj  bo  APP2 . EXE  nenehno  odsevala  spremembe ,  ki  jih  bo  nad  podatki  izvedla  SHARETEST . EXE . 

Button1 :  TButton ;

begin

GlobalData ^ . I  : =  StrToInt ( MaskEdit1 . Text ) ;

Tiskanje  v  Delphi-ju

V  tem  poglavju  se  boste  naučili  veliko  tiskalniških  tehnik  z  uporabo  gradnika  TPrinter .  Naučili  se  boste  preprostih  stvari ,  ki  jih  je  Delphi  še  poenostavil .  Spoznali  pa  boste  tudi  napredne  tehnike  tiskanja ,  ki  vas  bodo  popeljale  po  poti  uspešnega  programerja .

Objekt  TPrinter 

PageHeight  Višina  potiskanega  dela  strani ,  v  točkah  ( pixels ) .

end ;

Rewrite ( PText ) ;

{  Call  StretchDIBits  to  print  the  bitmap  }

end ;

Naprednejše  tiskanje 

Po  izvedbi  metode  EndDoc ( )  ne  smete  uporabljati  metod ,  ki  rišejo  na  tiskalnikovo  platno  ( metode  objekta  Printer . Canvas ) ,  saj  je  bilo  tiskanje  že  zaključeno .

2.  Identificirajte  enote  mere  na  ciljni  površini  oziroma  na  tiskalniškem  platnu .

const

EnvelopeHeightInPixels  : =  trunc ( EnvelopeHeightValue  *  PixPerInY ) ;

Izpis  18.5  MAINFORM . PAS ,  glavni  obrazec  programa  za  izpis  ovojnic

FeedType :  TFeedType ;  / /  Stores  the  feed  type  from  TEnvPosition

Različna  opravila  pri  tiskanju 

Popolne  informacije  o  vsakem  izmed  polj  se  nahajajo  v  Delphi-jevi  elektronski  pomoči ,  mi  pa  bomo  tukaj  spoznali  samo  nekatere  izmed  pogostejših .  Kljub  temu  pa  je  dobro  pogledati  tudi  v  elektronsko  pomoč  in  spoznati  še  kaj  novega  oziroma  takega ,  o  čemer  tu  sploh  ne  bomo  govorili .  Pozorni  morate  biti  tudi  zato ,  ker  so  nekatera  polja  različna  za  operacijska  sistema  Okna  95  in  Okna  NT .

Definicija  regulacije  tiskanja 

Regulacija  predstavlja  faktor ,  s  katerim  bodo  pomnožene  razdalje  pri  tiskanju .  Končna  stran  se  regulira  iz  fizičnih  mer ,  s  faktorjem  TDeviceMode . dmScale  /  100 .  Če  torej  želite  zmanjšati  grafiko  ( in  tekst )  na  polovico  velikosti ,  boste  postavili  dmScale  na  vrednost  50 .  Sledeča  koda  zmanjša  ves  izhod  na  50 %  originalne  velikosti :

Izpis  19.1  prikazuje ,  kako  uporabite  proceduro  Rewrite ( ) ,  da  ustvarite  novo  datoteko  in  ji  dodate  pet  vrstic  teksta .

Izpis  19.2  Branje  tekstovne  datoteke

finally

uses

var

procedure  TMain . FormCreate ( Sender :  TObject ) ;

Predpostavite ,  da  želite  shraniti  enega  ali  več  takšnih  zapisov  v  datoteko .  Kako  bi  lahko  to  storili ,  ste  videli  že  v  prejšnjem  podpoglavju ,  enako  pa  dosežete  tudi  z  deklaracijo :

Za  resnično  ugotavljanje  števila  zapisov  služi  metoda  GetNumRec ( ) .  Število  zapisov  izračuna  s  preprostim  deljenjem  velikosti  celotne  datoteke  ( zapisana  v  TStream . Size )  z  velikostjo  posameznega  zapisa .  Če  je  torej  velikost  datoteke  224  zlogov  in  velikost  zapisa  56  zlogov ,  se  v  datoteki  nahajajo  štirje  zapisi  ( 162 / 56  =  4 ) .

BlockRead ( F ,  Buffer ,  1 ,  NumRecRead ) ;

Buffer :  array [ 0 . . 128 ]  of  byte ;

AssignFile ( F ,  ‘ SOMEFILE . DAT ’ ) ;

unit  mainform ;

respective  file  variables  }

{  Read  SizeOf ( Buffer )  bytes  from  the  source  file

BlockRead ( SrcFile ,  Buffer ,  SizeOf ( Buffer ) ,  BytesRead ) ;

until  BytesRead  =  0 ;

BufPtr :  PChar ; 

Mode :  Integer ; / /  File  mode

fmShareDenyNone  Vsak  proces  lahko  odpre  to  datoteko  brez  omejitev .

Izpis  19.10  Preprost  primer  pomnilniško  preslikane  datoteke

V  naslednjem  koraku  preslikovalni  objekt  zares  ustvarimo  s  klicem  funkcije  CreateFileMapping ( ) .  V  primeru  napake  izvržemo  izjemo ,  sicer  nadaljujemo  in  ustvarimo  preslikovalno  datoteko .  V  primeru  napake  zopet  izvržemo  izjemo . 

Glavni  obrazec  iskalnega  programa  je  definiran  v  enoti  MAINFORM . PAS ,  ki  je  prikazana  na  izpisu  19.12 .

Za  pridobitev  informacij  o  razpoložljivih  diskih  na  sistemu  uporabite  Win32  API  funkcijo  GetDriveType ( ) .  Funkcija  sprejme  parameter  tipa  PChar  in  vrne  eno  izmed  celoštevilčnih  vrednosti ,  ki  so  zapisane  v  tabeli  19.6 .

below  }

3.  Število  zlogov  na  sektor . 

RootPath :  String ;  / /  Holds  the  drive  root  path

begin

Label12 . Caption  : =  ' X ' ;

end ;

function  GetWindowsDirectory ( lpBuffer :  PChar ,  uSize :  UINT ) ;  UINT ;

V  podatku  Time  je  zapisan  čas  zadnjega  popravila  ali  ustvaritve  datoteke .  Podatek  Size  seveda  vsebuje  velikost  datoteke  v  zlogih ,  podatek  Name  pa  ime  datoteke .  Podatek  Attr  vsebuje  njene  atribute .  Atributi  so  lahko  sestavljeni  iz  konstant ,  definiranih  v  tabeli  19.7

dwFileAttributes :  DWORD ;

Definicija  razreda  TVerInfoRes 

Uporaba  razreda  TVerInfoRes 

table1 . Next ;

Za  prikazovanje  podatkov  na  obrazec  boste  v  programu  uporabili  gradnik  TDBGrid .  Proces  priključitve  gradnikov ,  kot  je  TDBGrid ,  na  podatkovno  zbirko ,  zahteva  nekaj  korakov .  Sledeč  seznam  vsebuje  potrebne  korake  za  priključitev  gradnika  TDBGrid  na  podatke  gradnika  TTable :

Pomemben  rezultat ,  ki  ga  lahko  izveste  iz  zgornjih  dejstev ,  je :  » Pri  prazni  zbirki  sta  EOF  in  BOF  True ! « .

Vrednosti  polj 

VarArr  : =  table1 [ ‘ Common _ Name ; Category ; Length _ In ’ ] ;

OPOMBA :  Če  vas  zanima ,  koliko  polj  se  nahaja  v  podatkovni  zbirki ,  uporabite  lastnost  FieldCount

naslednik  razreda  TField  Podatkovni  tip  ustrezen  podatkovni  tip  v  Object  Pascal-u

TAutoIncField  ftAutoInc  Integer

Slika  20.9  ‘ Metanje ’  polj  na  obrazec

ftFmtMemo  Paradox-ov  formatiran  tekst

Primer  uporabe  BLOB  polj 

WavETitle  Character  25

Gumb  ADD  je  uporabljen  za  izbor  WAV  datoteke  na  disku  in  dodajanje  v  tabelo .  Odzivna  procedura  njegovega  onClick  dogodka :

B  : =  TBlobStream . Create ( Table1Wave ,  bmRead ) ;  / /  create  blob  stream

Stanja  podatkovne  zbirke 

FindKey ( ) 

Za  uporabo  metode  ApplyRange ( )  ( za  vzpostavitev  območja )  sledite  trem  korakom :

12.  Postavite  lastnost  TableType  in  tako  povejte ,  kakšnega  tipa  tabelo  želite .  Če  postavite  lastnost  na  ttDefault ,  bo  tip  tabele  odvisen  od  končnice  prej  podanega  imena  ( na  primer ,  če  je  končnica  imena  . DB ,  bo  Delphi  ustvaril  Paradox-ovo  tabelo ,  če  pa  je  končnica  . DB ,  bo  ustvaril  DBase  tabelo ) .

13.  Uporabite  Table . FieldDefs.Add ( )  metodo  in  dodajte  definicije  polj  v  tabeli .  Metoda  Add ( )  sprejme  štiri  parametre :

Niz  opcij  tipa  TIndexOptions ,  ki  določajo  tip  indeksa .

procedure  Range1Click ( Sender :  TObject ) ;

end ;

{  Public  declarations  }

Tip  Pomen

Velikost  pomeni  celotno  število  znakov  v  polju .  Za  številčna  polja  mora  biti  ta  vrednost  manjša  ali  enaka  20 .

4.  Z  desnim  miškinim  gumbom  kliknite  po  gradniku  TBatchMove  in  izberite  opcijo  Execute  iz  lokalnega  menuja .

2.  Pritisnite  gumb  ‘ Add ’  v  pogovornem  oknu  ‘ Dialog  Sources ’  in  odprlo  se  vam  bo  pogovorno  okno  ‘ Add  Data  Source ’ ,  ki  je  prikazano  na  sliki  20.24 .  Iz  seznama  izberite  opcijo  » Microsoft  Access  Driver  ( * . mdb ) «  in  pritisnite  OK .

Slika  20.25  Pogovorno  okno  ‘ ODBC  Microsoft  Access  2.0  Setup ’

SKALABILNE  APLIKACIJE :  Pogostokrat ,  ko  bo  govora  o  razvoju  aplikacij  tipa  odjemalec / strežnik  znotraj  Delphi-ja ,  boste  slišali  besedo  skalabilnost .  Kaj  pa  je  skalabilnost ?  Nekaterim  to  pomeni  preprost  dostop  do  strežnikovih  podatkov  z  uporabo  Delphi-jevih  podatkovnih  kontrol ,  drugim  pa  to  pomeni  magično  spremembo  namizne  aplikacije  v  aplikacijo  tipa  odjemalec / strežnik  samo  z  zamenjavo  sinonima .

Ena  izmed  najpogostejših  napak  pri  konceptih  tehnologij  odjemalec / strežnik  je  v  nepoznavanju  dela  strežniških  podatkovnih  baz .  Takšne  podatkovne  baze  obdelujejo  nize  podatkov  in  ne  posameznih  zapisov .  To  pomeni ,  da  odjemalčeve  aplikacije  direktno  ne  obdelujejo  tabel  podatkov  ( kakor  je  to  v  navadi  pri  namiznih  podatkovnih  aplikacijah ) ,  temveč  obdelujejo  samo  manjše  podmnožice  teh  podatkov .

SQL  podatkovne  baze  obravnavajo  zaščito  drugače  kot  namizne  podatkovne  baze .  Omogočajo  enakovredno  zaščito  z  gesli  za  celotno  podatkovno  bazo ,  a  ob  tem  omogočajo  tudi  specifične  zaščite  samo  posameznih  objektov ,  kot  so  pogledi ,  shranjene  procedure . . . ( več  o  teh  objektih  bomo  govorili  kasneje ) .  To  pa  z  drugimi  besedami  pomeni ,  da  je  lahko  zaščita  podatkov  na  strežniku  narejena  glede  na  uporabniške  potrebe  po  podatkih .

Procesiranje  podatkov .  SQL  omogoča  odjemalcem  spreminjanje ,  dodajanje  in  brisanje  zapisov .  To  lahko  dosežete  s  preprostim  SQL  ukazom  ali  pa  preko  shranjene  procedure  na  strežniku .

Za  definiranje  tabele ,  njenih  polj  in  kakršnih  koli  integritetnih  omejitev  uporabite  ukaz  CREATE  TABLE .  Izpis  21.1  prikazuje ,  kako  ustvariti  InterBase  tabelo . 

Uporaba  domen 

Izpis  21.3  prikazuje  preprosto  izvršljivo  shranjeno  proceduro .

old . EMP _ NO ,

BEFORE  DELETE  Sproži  se  pred  brisanjem  zapisa  iz  tabele .

Prej  omenjene  variacije  stavka  GRANT  veljajo  tudi  za  shranjene  procedure .

Handle  Uporabljen  za  direkten  dostop  do  BDE-jevih  funkcij  in  procedur .

KeepConection  Spremenljivka  tipa  Boolean ,  ki  pove ,  ali  naj  TDataBase  ostane  povezana  s  podatkovno  bazo ,  četudi  ni  odprt  nobeden  TDataSet .  Ta  lastnost  se  uporablja  za  večjo  hitrost  in  izboljšanje  performans  aplikacije .

procedure  Button2Click ( Sender :  TObject ) ;

implementation

end ;

begin

Za  ilustracijo  te  podedovane  slabosti  gradnika  TTable  za  dostop  do  velikih  tabel  si  zamislite ,  da  odprete  TTable  samo  za  pridobitev  nekaj  zapisov .  Čas ,  ki  je  potreben ,  da  se  odpre  SQL  tabela ,  je  premosorazmeren  z  njeno  velikostjo .  Ko  izdate  podatkovnemu  strežniku  ukaz ,  kot  je  prikazan  spodaj ,  gradnik  TTable  najprej  podatkovnemu  strežniku  pošlje  serijo  SQL ,  da  od  njega  dobi  podatke  o  tabeli ,  ključih ,  indeksih . . . :

Čeprav  je  gradnik  TTable  sposoben  iskanja  posameznih  zapisov  z  uporabo  metode  FindKey ( ) ,  so  njegove  sposobnosti  pri  SQL  podatkovnih  bazah  omejene .  Prvič ;  metoda  FindKey ( )  lahko  išče  zapise  samo  nad  indeksiranim  poljem  oziroma  indeksiranimi  polji ,  kadar  jih  je  več .  Gradnik  TQuery  nima  te  omejitve ,  saj  vso  komunikacijo  izvajate  preko  SQL-a .  Res  je ,  da  metoda  FindKey ( )  ustvari  SELECT  SQL  ukaz  za  strežnik ,  toda  rezultat  bo  vseboval  vsa  polja  tabele ,  čeprav  jih  vi  morda  potrebujete  samo  nekaj .  To  velja  tudi  v  primeru ,  če  ste  s  pomočjo  urejevalnika  polj  iz  gradnika  TTAble  izbrali  samo  nekaj  polj  ( rezultat  bo  še  vedno  vseboval  vsa  polja ,  le  prikazal  bo  samo  izbrane ! ) .

ParamByName ( ‘ CAPITAL . . . AsString  : =  ‘ Lima ’ ;

fDoloča  podatkovni  tip  float

finally

function  VarToInt ( const  V :  Variant ) :  Integer ;

SQL  stavki  ne  smejo  vsebovati  izračunanih  polj

SQL  stavki  ne  smejo  uporabljati  funkcij ,  kot  so  SUM  ali  AVG

DataBaseName  Ime  podatkovne  baze ,  ki  vsebuje  shranjeno  proceduro .  Ta  je  ponavadi  enaka  lastnosti  DataBaseName  gradnika  TDatabase ,  ki  je  povezan  z  želenim  podatkovnim  strežnikom .

Vhodni  in  izhodni  parametri  shranjene  procedure 

Pridobitev  rezultatov  shranjene  procedure  z  gradnikom  TQuery 

To  poglavje  vam  je  podalo  kar  veliko  informacij  s  področja  razvoja  programov  v  okoljih  odjemalec / strežnik .  Primerjali  smo  razvoj  programov  v  okolju  odjemalec / strežnik  s  tistimi  v  okolju  preprostih  namiznih  podatkovnih  baz .  Predstavili  smo  vam  tudi  različne  tehnike  v  Delphi-ju  in  InterBase-u ,  ki  vam  bodo  pomagale  pri  nadaljnjem  razvoju .  V  poglavju  30  pa  bomo  razvili  pravo  aplikacijo  tipa  odjemalec / strežnik ,  ki  bo  uporabljala  podatkovno  bazo  InterBase .

Delphi-jeve  podatkovne  sposobnosti  so  precej  impozantne ,  toda  tukaj  je  še  množica  operacij ,  ki  jih  Delphi-jevi  gradniki  ne  podpirajo ,  Borland  DataBase  Engine  ( BDE  -  Borland-ov  podatkovni  stroj )  pa  jih  vsebuje .  Ker  so  Delphi-jevi  podatkovni  gradniki  neodvisni  ( ali  pa  se  temu  zelo  približajo )  od  podatkovne  baze ,  s  katero  delajo ,  v  večini  primerov  ne  izkoriščajo  postopkov  BDE-ja ,  ki  so  vezani  na  določen  tip  podatkovne  baze .  To  poglavje  vam  predstavlja  notranjost  podatkovnega  stroja ,  v  katero  boste  morali  poseči ,  če  boste  želeli  specifične  stvari ,  ki  jih  podatkovni  gradniki  sicer  ne  omogočajo .

/ /  continue  function

T. CursorPosChanged ;

Check ( dbiGetRecord ( Handle ,  dbiNOLOCK ,  Nil ,  @ RP ) ) ;

Parameter  hDB  predstavlja  ročico  podatkovne  baze .  Posredovati  morate  lastnost  Handle  gradnika  TDatabase  ali  lastnost  DBHandle  kateregakoli  naslednika  razreda  TDataSet .

raise  EDatabaseError . Create ( SPackError ) ;

CRTblDesc  =  packed  record  {  Create / Restruct  Table  descr  }

szPassword  :  DBINAME ;  {  Password  ( optional )  }

iSecRecCount  :  Word ;  {  Number  of  security  defs  supplied  }

Dogodek  TApplication . OnMessage  se  zgodi  samo ,  kadar  pride  sporočilo  iz  aplikacijske  vrste  za  sporočila  ( poglejte  v  poglavje  6  za  podrobnejšo  razlago  terminologije ,  povezane  s  sporočili ) .  Sporočila ,  ki  se  nahajajo  v  aplikacijski  vrsti  za  sporočila ,  so  predvsem  tista ,  ki  se  ubadajo  z  upravljanjem  oken  ( na  primer  WM _ PAINT  in  WM _ SIZE )  ali  pa  tista ,  ki  so  bila  poslana  z  eno  izmed  okenskih  API  funkcij  ( PostMessage ( ) ,  PostAppMessage ( )  ali  BroadcastSystemMessage ( ) ) .  Problem  se  pojavi ,  ko  so  z  uporabo  funkcije  SendMessage ( )  poslani  tudi  drugi  tipi  sporočil  direktno  v  okensko  proceduro .  Če  se  to  zgodi ,  se  TApplication . OnMessage  sploh  ne  zgodi  in  zato  ne  morete  ugotoviti ,  ali  je  določeno  sporočilo  prispelo . 

Bodite  pozorni  na  dogodek  OnDestroy ,  kjer  se  najprej  obnovi  stara  okenska  procedura  ( OldWndProc ) ,  preden  se  nad  novo  ustvarjeno  izvede  funkcija  FreeObjectInstance ( ) .  Če  bi  pred  sprostitvijo  nove  procedure  ne  usposobili  stare ,  bi  bila  naša  aplikacija  nesposobna  prejemati  sporočila .  Ker  se  tako  ne  bi  mogla  odzvati  na  nobeno  sporočilo ,  bi  se  sesula ,  po  vsej  verjetnosti  pa  bi  to  porušilo  tudi  operacijski  sistem .

OPOMBA :  To  poglavje  vas  ne  bo  naučilo  programiranja  v  zbirniku .  Vam  bo  pa  vsekakor  prikazalo  njegovo  uporabo  ( v  Delphij-u ) . 

mov  eax ,  I

inc  eax

asm

POZOR :  V  vaših  aplikacijah  uporabljajte  samo  funkcijo  SetWindowHookEx ( )  in  ne  funkcije  SetWindowHook ( ) .  Slednja  je  bila  definirana  v  16 -  bitnih  Oknih ,  v  Win32  API-ju  pa  ni  več  implementirana .

Result  : =  CallNextHookEx ( HookHandle ,  Code ,  wParam ,  lParam ) ;

Key :  TKeyString ;

( Key :  ' ESCAPE ' ;  vkCode :  vk _ Escape ) ) ;

function  FindKeyInArray ( Key :  TKeyString ;  var  Code :  Byte ) :  Boolean ;

i :  word ;

paramH  Če  je  sporočilo  eno  izmed  sporočil  tipkovnice ,  vsebuje  to  polje  pregledno  kodo  tipke  ( scan  key  code ) ,  če  pa  gre  za  sporočilo  miške ,  to  polje  vsebuje  Y  koordinato  miške  v  zaslonskih  enotah .

var

{  get  a  hc _ GetNext  before  and  hc _ Skip  }

OPOMBA :  Za  ponovitev :  Funkcije  v  C + +  datotekah  ( . CPP )  bodo  vedno  imele  pohabljena  imena ,  če  jih  ne  deklarirate  kot  extern  » C « .

3.  Uporabite  zastavico  - u -  ob  klicu  BCC32  iz  ukazne  vrstice  ( ta  zastavica  prepreči  dodajanje  podčrtaja )

5.  Postavite  podčrtaj  pred  spremenljivko  v  Object  Pascal-ovi  programski  kodi .

/ /  globals

implementation

const

interface

uses

DDGM _ HandshakeMessage :  Cardinal ;

begin

Uporaba  integriranega  razhroščevalnika 

Uporaba  parametrov  ukazne  vrstice 

raise  ERegistryException . Create ( ' Delphi  is  not  properly  installed . ' ) ;

CPE  okno  se  v  TD32  deli  na  pet  površin :  površina  za  CPE ,  površina  za  dump ,  površina  za  registre ,  površina  za  zastavice  in  površina  za  sklad  ( oglejte  si  sliko  24.8 ) .  Vsaka  izmed  teh  površin  torej  omogoča  uporabniku  pogled  na  enega  izmed  pomembnih  delov  procesorja .

Tudi  na  površini  za  sklad  lahko  spreminjate  vrednosti ,  prikazuje  pa  vam  seveda  trenutni  sklad  programa .

SLIKA  25.2  % % Filter  Editor .

# # snd _ Alias _ ID  Parameter  # # pszSound  je  vnaprej  določen  identifikator  zvoka . 

Po  tem ,  ko  odprete  predvajalnik  medijev ,  v  krmilniku  # # OnClick  # # Buttona1  ne  pozabite  nastaviti  lastnosti  # # Nofity  na  # # True :

SLIKA  25.5 . . . Obrazec  začasnega  zaslona  predvajalnika  zgoščenk .

except

end ;

# # TimeFormat 

{ Ta  metoda  poišče  skupni  čas  in  posnetke  na  zgoščenki  ter  jih  prikaže . }

posnetkov

{ Ta  metoda  prikaže  trenutni  čas  trenutnega  posnetka }

begin

TrackDoneGauge . Progress  : =  ( 60  *  m )  +  s ;

var

Formatiranje  nizov 

SNumProcs  =  ' Number  of  Processorsq % d ' ;

dwAvailPhys :  DWORD ;

# # dwMemoryLoad  prikaže  število  od  0  do  100 ,  ki  približno  kaže  uporabo  pomnilnika .  0  pomeni ,  da  ni  v  uporabi  nič  pomnilnika ,  100  pa ,  da  je  v  uporabi  celoten  pomnilnik .

Add ( Format ( SMemUse ,  [ dwMemoryLoad ] ) ) ;

# # type

end ;

dwPageSize :  DWORD ;

lpMinimumApplicationAddress :  Pointer ;

wProcessorRevision :  Word ) ;

Polje  # # dwReserved  ostane  neuporabljeno .

# # lpMinimumApplicationAddress  vrne  najnižji  pomnilniški  naslov ,  do  katerega  lahko  dostopajo  aplikacije  in  DLL-ji .  Poskus  dostopa  do  pomnilniškega  naslova ,  nižjega  od  te  vrednosti ,  bo  verjetno  povzročil  kršitev  dostopa . 

Slika  26.3  kaže  # # InfoForm ,  ki  pri  zagonu  prikazuje  sistemske  informacije ,  vključno  z  informacijami  o  različici  operacijskega  sistema  in  imenika .

SLIKA  26.4 . . . Prikaz  nizov  okolja . 

Posnetki 

# # TH32CS _ SNAPMODULE  V  posnetku  vključuje  seznam  modulov  podanega  procesa  Win32 .

DoLBText ;

[ IntToHex ( T. th32ThreadID , 8 ) ,  GetClassPriorityString ( T. tpBasePri ) ,

repeat

dwFlags :  DWORD ;

HL.dwSize  : =  SizeOf ( HL ) ;

PHE ^  : =  HE ;  / / bomo  kasneje  imeli  na  voljo  dovolj  informacij  o  kopici

if  MemSize  >  ProcMemMaxSize  then  MemSize  : =  ProcMemMaxSize ;

Screen . Cursor  : =  crDefault ;

Izpis  26.2 .  nadaljevanje

Definiranje  aplikacije 

% % Ime  polja  Tip  Velikost  Pomen

# # CITY  A  40  Ime  mesta

Gradnik  # # TDataModule  za  to  aplikacijo  bomo  razložili ,  ker  # # DataModule1  glavnemu  obrazcu  aplikacije  nudi  dostop  do  podatkov .  # # DataModule1  je  prikazan  na  sliki  27.1 .

V  20.  poglavju  ste  spoznali  gradnik  # # TField .  Prek  področja  # # Fields  naslednika  # # TDataSet  ste  se  naučili  dostopiti  do  gradnikov  # # TField  pri  zagonu .  Naučili  ste  se  uporabljati  tudi  metodo  # # TDataSet . FieldsByName ( )  za  pridobivanje  dostopa  do  določenih  primerkov  # # TField .  Za  # # AddressTable  morate  izdelati  primerke  # # TField ,  saj  moramo  za  nekatera  polja  podati  določene  urejevalne  maske . 

Urejevalne  maske  predstavljajo  idealen  način  za  preverjanje  vhodnih  podatkov  uporabnika  ali  definiranje  tega ,  kako  naj  bodo  ti  podatki  prikazani .  To  so  nizi ,  izdelani  iz  posebnih  znakov ,  ki  definirajo ,  kaj  lahko  uporabnik  vpiše  ali  kako  naj  bodo  podatki  prikazani . 

> C < > cccccccccccccccccccccccccccccc ; ;

Prvi  in  zgornji  gradnik  # # TGroupBox  se  imenuje  # # grName .  To  polje  skupine  vsebuje  gradnik  # # TNoteBook ,  imenovan  # # NameNoteBook ,  ki  ima  dve  strani :  # # PersonalPage  in  # # BusinessPage .  Strani  se  med  seboj  nekoliko  razlikujeta .  # # PersonalPage ,  prikazana  na  sliki  27.3  vsebuje  tri  gradnike  # # TDBEdit ,  ki  so  povezani  s  polji  # # LAST _ NAME ,  # # FIRST _ NAME  in  # # MIDDLEINIT  iz  # # ADDRESS . DB .

Drugi  gradniki 

Kot  smo  že  omenili  # # TDBCheckBox , BusinessAddressCB  spremeni  # # AcativePage  iz  # # NameNoteBook .

Krmilnik  dogodka  # # OnClick  iz  # # ClipboardBtn  # # ClipboardBtnClick ( )  določa ,  ali  naj  bo  poklicana  metoda  # # PasteFromClipboard ( )  ali  # # CopyToClipboard ,  odvisno  od  vrednosti  spremenljvke  # # Mode .

% % Ime  polja  % % Tip  % % Velikost  % % Pomen

# # TDataModule  aplikacije  -  centraliziranje  dostopa  do  baze  podatkov 

Ta  obrazec  vsebuje  le  klice  metodam  # # DataModula1  za  dodajanje  ali  odstranjevanje  zapisov  alarmov .  Njegova  izvorna  koda  je  prikazana  v  izpisu  28.4 .

Definicija  komuniciranja  prek  zaporednih  vrat 

Krmiljenje  poteka 

Zdaj  ste  pripravljeni  na  namestitev  gradnikov .  Z  uporabo  načina  za  namestitev  gradnikov ,  uporabljenega  v  11.  poglavju  " Pisanje  prilagojenih  gradnikov  v  Delphiju " ,  z  izbiro  datoteke  APDREG . PAS  iz  pogovornega  okna  Add  Module ,  kot  je  prikazano  na  sliki  29.1 ,  namestite  gradnike  APD .  Ta  datoteka  je  v  imeniku  C : \ APD \ ,  ki  ste  ga  ravnokar  izdelali .  Async  Professional  for  Delphi  vključuje  tudi  podprograme  za  pošiljanje  in  prejemanje  telefaksov ,  ki  pa  jih  ne  bomo  razložili .  Če  želite  uporabiti  gradnike  telefaksa  APD ,  boste  morali  namestiti  tudi  modul  APDFREG . PAS .

Gradnik  # # TTerminal 

POZOR  Razen  če  nimate  posebne  strojne  opreme ,  ki  bi  omogočala  delitev  IRQ-jev ,  na  en  IRQ  ne  morete  priključiti  dveh  različnih  naprav .  To  lahko  povzroči  neskladje ,  pa  tudi  odpoved  aplikacije .  Zaradi  tega  npr.  miško  priključite  na  COM3 ,  modem  pa  na  COM1 .

Izpis  29.1 .  prikazuje  izvorno  kodo  za  glavni  obrazec .

SLIKA  29.7 . . . Elektronska  oglasna  deska  TurboPower .

V  prejšnjih  poglavjih  ste  videli ,  kako  se  izdelajo  aplikacije  baze  podatkov  za  namizne  baze  podatkov ,  kot  je  Paradox .  V  tem  zadnjem  poglavju  bomo  pokazali ,  kako  se  izdela  aplikacija  baze  podatkov  z  uporabo  konceptov ,  razloženih  v  21.  poglavju  " Razvijanje  odjemalsko / strežniških  aplikacij " .  Uporabljen  zadnji  del  baze  podatkov  bo  Local  Interbase .  Aplikacija  bo  izdelana  za  tipičen  poslovni  model .  Ta  poslovni  model  od  aplikacije  zahteva ,  da  vodi  tri  osnovne  nize  podatkov :

Preden  definirate  tabele ,  prožila  ali  katerekoli  druge  modne  zadeve ,  razmislite  o  definiranju  domen ,  ki  bodo  uporabljene  v  celotni  kodi  SQL ,  ki  tvori  metapodatke . 

Tabela  CUSTOMER  predstavlja  podatkovni  objekt  stranke  in  je  definirana  tako :

Tabela  PART  predstavlja  inventar  trgovine .  Definicija  te  tabele  je  dokaj  preprosta :

CONSTRAINT  PPART _ NUMBER  PRIMARY  KEY  ( PART _ NUMBER ) ) ;

V  tabeli  ITEMS  so  postavke  ali  deli  določene  prodaje .  Tabela  SALES  ima  povezave  s  tabelo  ITEMS  in  je  povezano  s  poljema  # # SALE _ NUMBER  in  # # SALE _ NO  v  vsaki  tabeli .  Tabela  ITEMS  je  definirana  tako :

# # GRANT  SELECT ,  UPDATE  ON  CUSTOMER  TO  PUBLIC  WITH  GRANT  OPTION ;

Odločili  smo  se ,  da  bomo  najprej  razložili  uporabniško  definirane  podprograme ,  saj  veliko  drugih  podprogramov  uporablja  te  metode .  Te  metode  so  povezane  predvsem  z  načinom  prikaza  obrazca  oziroma  s  tem ,  kateri  gradniki  in  menijske  postavke  so  vidni .

# # EIntOverflow  -  Do  nje  pride ,  če  poskušate  izvesti  operacijo ,  ki  presega  zmogljivosti  tipa  integralne  spremenljivke .  Do  te  izjeme  pride  kot  rezultat  napake  med  izvajanjem  215 .  Do  te  izjeme  bo  prišlo  le ,  če  je  omogočeno  preverjanje  prelivanja  z  uporabo  { $ Q + }  v  kodi  ali  Options  |  Project  |  Compiler  |  Overflow  v  IDE-ju .  To  izjemo  bo  povzročila  naslednja  koda : 

# # EInvalidCast  -  Do  te  izjeme  pride ,  če  razredu  za  dodelitev  nezdružljivega  razreda  uporabite  operator  # # as .  Do  te  izjeme  pride  kot  rezultat  napake  med  izvajanjem  219 .  To  izjemo  bo  povzročila  naslednja  koda : 

# # EStreamError  -  Ta  izjema  je  osnovni  razred  vseh  izjem  pretoka .  Ta  izjema  navadno  kaže  problem  pri  nalaganju  # # TStrings  iz  pretoka  ali  pri  nastavitvi  zmogljivosti  pretoka  pomnilnika .  Naslednji  razredi  izjem  kažejo  druga  specifična  stanja  napak :

ERROR _ INVALID _ ACCESS12Dostopna  koda  ni  veljavna .

ERROR _ BAD _ LENGTH24Program  je  izdal  ukaz ,  vendar  njegova  dolžina  ni  pravilna .

ERROR _ SHARING _ BUFFER _ EXCEEDED36Za  deljenje  je  odprtih  preveč  datotek .

ERROR _ NOT _ SUPPORTED50Omrežna  zahteva  ni  podprta .

ERROR _ INVALID _ AT _ INTERRUPT _ TIME104Med  prekinitvijo  ne  morem  zahtevati  ekskluzivnih  semaforjev . 

ERROR _ NOT _ JOINED136Sistem  je  poskusil  zbrisati  # # JOIN  pogona ,  ki  ni  združen .

ERROR _ SIGNAL _ PENDING162Signal  je  že  v  teku .

ERROR _ INVALID _ SEGMENT _ NUMBER180Sistem  je  odkril  številko  segmenta ,  ki  ni  bila  pravilna .

ERROR _ BAD _ EXE _ FORMAT193 % 1  ni  veljavna  aplikacija  za  Okna  NT .

ERROR _ RING2SEG _ MUST _ BE _ MOVABLE200Segment  kode  ne  sme  biti  večji  ali  enak  64  kb .

ERROR _ CANTWRITE1013V  konfiguracijski  registracijski  ključ  se  ne  da  pisati .

ERROR _ CHILD _ MUST _ BE _ VOLITILE1021Ne  morem  izdelati  stabilnega  podključa  pod  nestalnim  glavnim  ključem .

ERROR _ INVALID _ BLOCK _ LENGTH1106Pri  dostopanju  do  novega  traku  z  več  particijami  velikost  trenutnega  bloka  ni  pravilna .

ERROR _ PORT _ UNREACHABLE . 1234V  oddaljenem  sistemu  na  ciljni  končni  točki  omrežja  ne  deluje  nobena  storitev .

ERROR _ INVALID _ ID _ AUTHORITY1343Podana  vrednost  je  bila  neveljavna  vrednost  za  pooblastilo  identifikatorja .

ERROR _ INVALID _ SERVER _ STATE1352Strežnik  upravljalnika  varnostnih  šifer  ( SAM )  ali  lokalnega  varnostnega  pooblastila  ( LSA )  je  bil  v  napačnem  stanju  za  izvršitev  varnostne  operacije .

ERROR _ NON _ MDICHILD _ WINDOW1445Ne  morem  obdelati  sporočila  iz  okna ,  ki  ni  okno  vmesnika  več  dokumentov  ( MDI ) .

ERROR _ NETLOGON _ NOT _ STARTED1792Klic  oddaljene  procedure  za  to  nit  je  že  v  teku .  Narejen  je  bil  poskus  prijave ,  vendar  storitev  omrežne  prijave  ni  bila  pognana .

ERROR _ ACCOUNT _ EXPIRED1793Uporabniška  šifra  se  je  iztekla .

ERROR _ UNKNOWN _ PORT1796Podana  vrata  niso  znana .

ERROR _ UNKNOWN _ PRINTPROCESSOR1798Tiskalni  procesor  ni  znan .

ERROR _ INC _ BACKUP4003Izdelava  varnostne  kopije  ni  uspela .  Je  bila  celotna  varnostna  kopija  že  izdelana ?

10280404Odpiranje  ni  uspelo .

46171209SQL  prodajalca .

46741242INTRBASE  -  isc _ rollback _ transaction .

4699125BMSSQL  -  dbfreebuf .

481912D3SYBASE  -  dbsetopt .

89662306Pokvarjena  zaklepalna  datoteka .

94812509Omejitev  zaporedne  številke  ( Paradox ) .

9738260AOperacija  odpiranja  podrobne  table  ni  uspela .

97482614Polja  referenčne  integritete  morajo  biti  indeksirana .

9997270DIndeks  ne  obstaja .

100182722Neveljaven  imenik .

10045273DNezdružljive  strukture  zapisov .

102412801Zapis  je  zaklenil  drug  uporabnik .

107722A14Prehodno  povezavo  SQL  je  potrebno  deliti .

110202B0CNeveljavna  dostopna  koda .

110432B23Datoteka  že  obstaja .

110472B27Neznanana  notranja  napaka  operacijskega  sistema .

112682C04Ne  morem  zakleniti  omrežne  datoteke .

117892E0DNapaka  tipa  v  izrazu  CALC .

118042E1CVzorčni  element  je  uporabljen  v  dveh  poljih  z  nezdružljivim  tipom  ali  z  BLOB .

118602E54Neveljaven  izraz  v  vrstici  INSERT .

119582EB6SELECT  DISTINCT  ne  smete  uporabiti  z  UNION ,  razen  če  ne  uporabljate  UNION  ALL.

119592EB7GROUP  BY  je  zahtevan ,  če  so  v  nastalem  nizu  uporabljena  agregatna  in  neagregatna  polja .

125463102Neznan  tip  baze  podatkov .

135743506Neveljaven  tip  povezave .

13578350AObjekt  je  v  logičnem  DB .

158753E03Napačna  različica  gonilnika .

158763E04Napačen  tip  gonilnika .
